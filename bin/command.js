// Generated by CoffeeScript 1.9.2
var args, clip_range, cmds, command, commands, parse_range, seuss, usage, usage_error;

usage = "Usage: seuss command [parameter] file\n\nView:\n  cat                     Print entire queue contents\n  peek n..m               Print rows n..m inclusive\n\nManipulate:\n  rm n..m                 Remove and print rows n..m inclusive\n  insert index message    Insert a message into the queue\n  enqueue message         Add message to the queue\n  dequeue                 Remove and print a message from the queue\n  purge                   Remove all messages from the queue\n\nOptions:\n  -h                      Display this usage information\n  -v                      Display the version number\n";

process.on('uncaughtException', function(err) {
  console.error('  Caught exception: ');
  return console.error(err.stack);
});

usage_error = (function(_this) {
  return function(message) {
    console.error();
    console.error("  " + message);
    console.error();
    console.error(usage);
    return process.exit(1);
  };
})(this);

args = process.argv.slice(2);

if (args.length === 0) {
  return console.error(usage);
}

seuss = require('../');

commands = {
  peek: function(r, path) {
    var i, index, message, messages, ref, ref1, results;
    messages = seuss.read(path);
    if (messages.length === 0) {
      return console.error('No messages in queue');
    }
    clip_range(r, messages);
    results = [];
    for (index = i = ref = r.start, ref1 = r.end; ref <= ref1 ? i <= ref1 : i >= ref1; index = ref <= ref1 ? ++i : --i) {
      message = messages[index - 1];
      results.push(console.log(index + ") " + message));
    }
    return results;
  },
  rm: function(r, path) {
    var i, index, j, len, len1, message, messages, queue, removed, results;
    messages = seuss.read(path);
    if (messages.length === 0) {
      return console.error('No messages in queue');
    }
    clip_range(r, messages);
    if (r.start > r.end) {
      r = {
        start: r.end,
        end: r.start
      };
    }
    removed = messages.splice(r.start - 1, r.end - r.start + 1);
    queue = seuss.create(path);
    for (i = 0, len = messages.length; i < len; i++) {
      message = messages[i];
      queue.enqueue(message);
    }
    queue.close();
    results = [];
    for (index = j = 0, len1 = removed.length; j < len1; index = ++j) {
      message = removed[index];
      results.push(console.log((index + r.start) + ") " + message));
    }
    return results;
  },
  enqueue: function(message, path) {
    var queue;
    queue = seuss.open(path);
    queue.enqueue(message);
    return queue.close();
  },
  dequeue: function(path) {
    var queue;
    queue = seuss.open(path);
    console.log(queue.dequeue());
    queue.compact();
    return queue.close();
  },
  cat: function(path) {
    var i, index, len, message, messages, results;
    messages = seuss.read(path);
    results = [];
    for (index = i = 0, len = messages.length; i < len; index = ++i) {
      message = messages[index];
      results.push(console.log((index + 1) + ") " + message));
    }
    return results;
  },
  purge: function(path) {
    var queue;
    queue = seuss.create(path);
    return queue.close();
  },
  insert: function(index, message, path) {
    var i, len, messages, queue;
    messages = seuss.read(path);
    index = Math.max(index, 1);
    index = Math.min(index, messages.length + 1);
    messages.splice(index - 1, 0, message);
    queue = seuss.create(path);
    for (i = 0, len = messages.length; i < len; i++) {
      message = messages[i];
      queue.enqueue(message);
    }
    queue.close();
    return console.log(index + ") " + message);
  }
};

clip_range = function(r, messages) {
  if (r.start === '') {
    r.start = 1;
  }
  if (r.end === '') {
    r.end = messages.length;
  }
  r.start = Math.min(r.start, messages.length);
  r.start = Math.max(r.start, 1);
  r.end = Math.min(r.end, messages.length);
  return r.end = Math.max(r.end, 1);
};

parse_range = function(s) {
  var chunks;
  if (s == null) {
    return {
      start: 1,
      end: 1
    };
  }
  chunks = s.split('..');
  if (chunks.length === 1) {
    return {
      start: s,
      end: s
    };
  } else if (chunks.length === 2) {
    return {
      start: chunks[0],
      end: chunks[1]
    };
  } else {
    return null;
  }
};

cmds = {
  peek: function() {
    var path, r;
    if (args.length === 1) {
      r = parse_range();
      path = args[0];
    } else if (args.length === 2) {
      r = parse_range(args[0]);
      path = args[1];
    }
    if (path == null) {
      usage_error('seuss peek requires two arguments - the message index or range to print and the queue path');
    }
    return commands.peek(r, path);
  },
  rm: function() {
    var path, r;
    if (args.length === 1) {
      r = parse_range();
      path = args[0];
    } else if (args.length === 2) {
      r = parse_range(args[0]);
      path = args[1];
    }
    if (path == null) {
      usage_error('seuss rm requires two arguments - the message index or range to remove and the queue path');
    }
    return commands.rm(r, path);
  },
  insert: function() {
    if (args.length === 3) {
      return commands.insert(args[0], args[1], args[2]);
    }
    return usage_error('seuss insert requires three arguments - the index to insert, the message to insert and the queue path');
  },
  enqueue: function() {
    if (args.length === 2) {
      return commands.enqueue(args[0], args[1]);
    }
    return usage_error('seuss enqueue requires two arguments - the message to enqueue and q the queue path');
  },
  dequeue: function() {
    if (args.length === 1) {
      return commands.dequeue(args[0]);
    }
    return usage_error('seuss dequeue requires one argument - the queue path');
  },
  cat: function() {
    if (args.length === 1) {
      return commands.cat(args[0]);
    }
    return usage_error('seuss cat requires one argument - the queue path');
  },
  purge: function() {
    if (args.length === 1) {
      return commands.purge(args[0]);
    }
    return usage_error('seuss purge requires one argument - the queue path');
  },
  '-h': function() {
    return console.log(usage);
  },
  '-v': function() {
    var pjson;
    pjson = require('../package.json');
    return console.log(pjson.version);
  }
};

command = args[0];

args.shift();

if (cmds[command] != null) {
  return cmds[command]();
}

usage_error(command + " is not a known seuss command");
